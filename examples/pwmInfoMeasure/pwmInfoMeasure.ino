/*
Example program to demonstarte usage od PWMinfo library 
https://github.com/Gjorgjevikj/PWMsense
for PWM signal measures, estimating frequency and duty

(c) Dejan Gjorgjevikj, 2017
Revised:
23.08.2018 - clean up ...
09.09.2018 - renaming, simplifying, imroving

*/

/* 
Estimates the frequency and the duty of a PWM signal 
based on timing the rising and falling edges of the signal using an interrupt
and only one full cycle
*/

#include <PWMinfo.h>

// seting up some board specifics 
// ... PWM generation is 8 bit precise on ATmega 
#if defined(ARDUINO_ARCH_AVR)
#pragma message("ARDUINO_ARCH_AVR defined!")
#define PCT(x) ((x)*256/100) 
#define pct *256/100


// generating PWM to connect it for measuring 
// on the same device for testing purposes only... if you have no other source
const static int OUT_PWM_PIN1 = 10;
// const static int OUT_PWM_PIN2 = 11;
void setPwmFrequency(int pin, int divisor);

// pins to be used for measuring PWM signals
// we can configure ANY pin that supports Pin Change interrupt 
// and any number of them simultaneosly (subject to maximum speed, duty, produced code size...)
const static int MEASURE_PIN1 = 4; // we could choose any pin
const static int MEASURE_PIN2 = 5; // we could choose any pin
// const static int MEASURE_PIN3 = 6; // we could choose any pin
// const static int MEASURE_PIN4 = 12; // we could choose any pin
const static int ANALOG_IN_PIN = A0;
// connect the wiper of a potentiometer to A0 an the fixed ends to Vcc and Gnd to cange the duty of the signal generated on OUT_PWM_PIN1 

#elif defined (ESP8266) 

#pragma message("ESP8266 defined!")
#define PCT(x) ((x)*PWMRANGE/100)
#define pct *PWMRANGE/100

// generating PWM to connect it for measuring if you have no other source
// just connect OUT_PWM_PIN1 to MEASURE_PIN1 and MEASURE_PIN2
const static int OUT_PWM_PIN1 = D5;
// const static int OUT_PWM_PIN2 = D6;

// pins to be used for measuring PWM signals
const static int MEASURE_PIN1 = D1; // we could choose any pin
const static int MEASURE_PIN2 = D2; // we could choose any pin
// const static int MEASURE_PIN3 = D3; // we could choose any pin
// const static int MEASURE_PIN4 = D4; // we could choose any pin
const static int ANALOG_IN_PIN = A0;
#endif

// declare the object that will be bounded to pin to monitor the PWM signal
// since the objcts are generated by template and have only static functions 
// there is no constructor call, but rather a user defined type definition
typedef PWMinfo<MEASURE_PIN1> pm1; // PWMinf(pm1, MEASURE_PIN1);
//PWMinf(pm2, MEASURE_PIN2); // or use the macro

void toogleLed()
{
	static bool ledOn = false;
	ledOn = !ledOn;
	digitalWrite(LED_BUILTIN, ledOn);
}


void setup() 
{
  Serial.begin(9600);
  // start the PWM generation on OUT_PWM_PIN1
  pinMode(OUT_PWM_PIN1, OUTPUT);
  analogWrite(OUT_PWM_PIN1, 35 pct);
  delay(100);

  Serial.println(F("One-time direct measurement ..."));
  // define the object to measure the parameters of a PWM signal brought to pin MEASURE_PIN2
  PWMinf(pwmMonitor, MEASURE_PIN2);
  // start the mesuring 
  pwmMonitor::begin();
  // can do something else here ...
  // check if sufficent transitions had happened so that the frequency and duty of the signal can be estimated
  int c = 100;
  while (!pwmMonitor::valid())
  {
	  // this can be an endless wait if there is no transitions in the signal
	  c--;
	  delay(1);
	  if (c <= 0)
		  break;
  }
  // Hopefully we can estimate the duty and the frequency of the signal now
  if (pwmMonitor::valid())
	  Serial.print(F("OK ")); // valid estimations
  else
	  Serial.print(F("** ")); // not enought data to esimate - no changes in signal
  // but if we call frequency() or duty() some invalid values will be returned anyway ...

	Serial.print(F("f="));
	Serial.print(pwmMonitor::frequency());
	Serial.print(F("Hz "));
	Serial.print(F("d="));
	Serial.print(pwmMonitor::duty());
	Serial.println(F("% "));

	//we can stop monitoring now
	pwmMonitor::end();
	// or we can keep it running so we can call frequency() or duty() anywhere without waiting
	// to estimate the signal parameters according its last full cycle

	Serial.println(F("One-time measurement using template functions and pin ..."));
	Serial.print(F("f="));
	Serial.print(OnePulseFreqEstimate<MEASURE_PIN2>(100)); // wait no more than 100ms
	// this is a blocking call - will wait for one full cycle of the signal or the timeout to pass
	Serial.print(F("Hz "));
	Serial.print(F("d="));
	Serial.print(OnePulseDutyEstimate<MEASURE_PIN2>(150)); // wait no more than 150ms
	Serial.println(F("% "));

	delay(1000);
	Serial.println(F("Start continous measurement ..."));
	pwmMonitor::begin(); // start monitoring MEASURE_PIN1 again
	Serial.println(F("Duty set to 10%"));
	analogWrite(OUT_PWM_PIN1, 10 pct);
	pwmMonitor::reset(); // reset to start from scratch without calling end() nad then begin()
	unsigned long timew = millis();
	while (!pwmMonitor::valid() && millis() - timew < 200)
		yield();

	Serial.print(F("f="));
	Serial.print(pwmMonitor::frequency());
	Serial.print(F("Hz "));
	Serial.print(F("d="));
	Serial.print(pwmMonitor::duty());
	Serial.println(F("% "));

	Serial.println(F("Duty set to 85%"));
	analogWrite(OUT_PWM_PIN1, 85 pct);
	pwmMonitor::reset(); // reset to start from scratch without calling end() nad then begin()
	while (!pwmMonitor::valid() && millis() - timew < 200)
		yield();

	Serial.print(F("f="));
	Serial.print(pwmMonitor::frequency());
	Serial.print(F("Hz "));
	Serial.print(F("d="));
	Serial.print(pwmMonitor::duty());
	Serial.println(F("% "));

	// stop pwmMonitor as it was local
	pwmMonitor::end();
	Serial.println(F("Entering the main loop..."));
	Serial.println(F("You can change the duty using the pot @ A0"));
	Serial.println(F("and the frequency through serial."));
	// pm1 is global - start it now for continous monitoring
	pm1::begin();
	//pm2::begin();
	delay(100);
}

unsigned long ms = 0;

void loop() 
{
	int aval = analogRead(ANALOG_IN_PIN);
#if defined(ARDUINO_ARCH_AVR)
	// on Arduino analogRead is 10 bit (0-1023), analogWrite is 8 bit (0-255)
	analogWrite(OUT_PWM_PIN1, map(aval, 0, 1023, 0, 255));
#elif defined (ESP8266) 
	// on ESP8266 analogRead is 10 bit (0-1023), analogWrite is initially 10 bit (0-PWMRANGE)
	analogWrite(OUT_PWM_PIN1, map(aval, 0, 1023, 0, PWMRANGE));
#endif

	// ... will continually report the duty cycle and the Frequency of the PWM signal
	// interrupts are working all the time..., report the values every second
	if (millis() - ms > 1000)
	{
		ms = millis();

		Serial.print(F("A0="));
		Serial.print(aval);
		Serial.print(' ');
		
		// contionously...
		Serial.print(F("pm1:f="));
		Serial.print(pm1::frequency());
		Serial.print(F("Hz "));
		Serial.print(F("pm1:d="));
		Serial.print(pm1::duty());
		Serial.print(F("% \t"));

		// hit-and-run
		Serial.print(F("hr:f="));
		Serial.print(OnePulseFreqEstimate<MEASURE_PIN2>(100));
		Serial.print(F("Hz "));
		Serial.print(F("hr:d="));
		Serial.print(OnePulseDutyEstimate<MEASURE_PIN2>(100));
		Serial.print(F("% "));

		// or both in 1 cycle
		PWMinf(pm2, MEASURE_PIN2);
		// start the mesuring 
		pm2::begin();
		// check if sufficent transitions had happened so that the frequency and duty of the signal can be estimated
		unsigned long timew = millis();
		while (!pm2::valid() && millis() - timew < 200)
			yield();
		pm2::end();
		// can stop it immedatly, can use it later

		Serial.print(F("\tf="));
		Serial.print(pm2::frequency());
		Serial.print(F("Hz "));
		Serial.print(F("d="));
		Serial.print(pm2::duty());
		Serial.print(F("% "));

		Serial.println(); 
		toogleLed();
	}

	// check if there is anything entered on serial ...
#if defined(ARDUINO_ARCH_AVR)
	if (Serial.available())
	{
		char ch = Serial.read();
		unsigned long divisor = 0;
		switch (ch)
		{
		case '0': pm1::reset(); break;
		case '1': divisor = 1024;  break;
		case '2': divisor = 256;  break;
		case '3': divisor = 128;  break;
		case '4': divisor = 64;  break;
		case '5': divisor = 32;  break;
		case '6': divisor = 8;  break;
		case '7': divisor = 1; break;
		}
		if (divisor)
		{
			noInterrupts();
			pm1::reset(); 
			setPwmFrequency(OUT_PWM_PIN1, divisor);
			interrupts();
		}
		if (divisor == 1)
			Serial.println(F("This seems to high for me, but I'll try..."));
	}

#elif defined (ESP8266) 

	if (Serial.available())
	{
		char ch = Serial.read();
		unsigned long int freq2set = 0UL;
		switch (ch)
		{
		case '0': pm1::reset(); break;
		case '1': freq2set = 32UL; break;
		case '2': freq2set = 125UL; break;
		case '3': freq2set = 250UL; break;
		case '4': freq2set = 500UL;  break;
		case '5': freq2set = 1000UL;  break;
		case '6': freq2set = 2000UL;  break;
		case '7': freq2set = 4000UL;  break;
		case '8': freq2set = 8000UL;  break;
		case '9': freq2set = 16000UL;  break;
		case 'a':
		case 'A': freq2set = 24000UL; break;
		case 'b':
		case 'B': freq2set = 32000UL;
			Serial.println(F("Ich, uh, ... this is pretty fast..."));
			break;
		case 'c':
		case 'C': freq2set = 40000UL;
			Serial.println(F("This seems to high for me, but I'll try..."));
			break;
		}
		if (ch != '0' && freq2set != 0)
		{
			//			noInterrupts();
			analogWriteFreq(freq2set);
			analogWrite(OUT_PWM_PIN1, map(aval, 0, 1023, 0, PWMRANGE));
			//			interrupts();
			Serial.print(F("Frequency set to: "));
			Serial.println(freq2set);
			pm1::reset(); 
		}
		//Serial.print(F("PWM frq. changed to: "));
		//Serial.println(ch);
	}
#endif
	yield();
}

// for changing the frequency od pwm on AVR
#if defined(ARDUINO_ARCH_AVR)
void setPwmFrequency(int pin, int divisor) {
	byte mode;
	if (pin == 5 || pin == 6 || pin == 9 || pin == 10) {
		switch (divisor) {
		case 1: mode = 0x01; break;
		case 8: mode = 0x02; break;
		case 64: mode = 0x03; break;
		case 256: mode = 0x04; break;
		case 1024: mode = 0x05; break;
		default: return;
		}
		if (pin == 5 || pin == 6) {
			TCCR0B = TCCR0B & 0b11111000 | mode;
		}
		else {
			TCCR1B = TCCR1B & 0b11111000 | mode;
		}
	}
	else if (pin == 3 || pin == 11) {
		switch (divisor) {
		case 1: mode = 0x01; break;
		case 8: mode = 0x02; break;
		case 32: mode = 0x03; break;
		case 64: mode = 0x04; break;
		case 128: mode = 0x05; break;
		case 256: mode = 0x06; break;
		case 1024: mode = 0x07; break;
		default: return;
		}
		TCCR2B = TCCR2B & 0b11111000 | mode;
	}
}
#endif


